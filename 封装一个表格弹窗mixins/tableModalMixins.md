# 关于连续写了多个表格弹窗后引发的一点思考

## 背景

前段时间，在开发时发现自己的多个页面中，每个页面的查询条件里，都会有点击输入框后弹出一个表格弹窗，勾选数据后回显至输入框，然后点击查询这样的情况。一开始第一个表格弹窗我自己写了，后面几个也是copy写好的第一个。每次copy过来要改的地方也非常少，无非就是换一下参数名称、网络请求地址，而那些分页器、勾选器参数几乎是不需要修改的。既然要改的非常少，就证明可复用性是非常高的。然后再看下项目其它页面，发现有表格弹窗的场景还是非常多的，于是觉得很有必要对这些重复的逻辑再进行一次封装。

## mixins

对于vue2而言，对可复用逻辑进行封装，毫无疑问，就是mixins方案了。mixins是什么？用mixins时需要哪些知识点、注意事项？先来看下官网关于mixins的解释：

> 1. 混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。
> 2. 当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。

看起来，好像是那么回事，但又不知道具体怎么回事。在我理解里，只需要知道几点即可：

1. 在mixins.js文件里，this指向即将要混入进去的那个vue组件子实例。只要this能够指向vue实例，那你在mixins里干的所有事情，最后都变成了当前组件vue实例上的事情了。也就是代码写在mixins和写在vue文件里最后造成的结果是一模一样的（只要不发生冲突这个前提保证下hh）

   看起来好像很神奇吧，但其实能够指向当前vue实例的原因，不过也就是vue在混入的时候，将函数的this通过call指向了当前vue实例

2. 在初始化mixins时候可以为其传参，方法就和给普通构造函数传参没有任何区别

## 方案

简单了解了mixin后，就可以梳理思路后写代码了。首先思考都有哪些事件是可以封装的，哪些是不可以的？要想知道这个答案，就要先思考我们会对一个弹出框做的所有操作是什么呢？所有操作和操作时需要具有的行为如下：

1. 打开Modal，行为：需要重置参数、需要重置页数和页码
2. 点击确认按钮，行为：需要对勾选的数据项进行备份，需要将勾选的数据传至父组件
3. 点击取消按钮，行为：需要将勾选项重置为上一次备份值
4. 点击查询，行为：需要根据输入框的值作为最新的网络请求参数查询，需要重置页数
5. 点击重置，行为：需要重置参数、页数和页码
6. 点击分页，行为：发送网络请求查询数据

ok，到这所有情况都列出来了，那现在思考上面的问题，这些所有操作行为中，有哪些是可抽离封装，哪些是不可以的呢？在我看来，除了第2、第4点，其它所有行为都是可封装起来复用的。

为什么说第2点最好不要抽到mixins去呢？因为第2点中，当我们点击确认时，向父组件中传递数据这个行为是不可预测的，毕竟事件名也是由父组件去定义的，更何况有时候在传递前我们可能还会对数据进一步处理。

为什么说第4点最好不要抽到mixins去呢？也很简单，因为网络请求地址、入参、出参不能复用。所以这个肯定也是不能抽到mixins去的。

所以从开发的角度，在mixin里我们需要实现下面这些方法：

1. 根据不同的情况设置参数

2. 根据不同的情况设置分页器

3. 根据不同的情况设置勾选项

4. 根据不同场景设置表格为单选或多选

5. 根据不同场景类型重置参数

6. 解决antd不支持跨页多选问题

7. 解决antd勾选数据和勾选数据keys数组不一致问题

## 代码实现

- 见tableModalMixins.js文件

## 总结

虽然在vue3已经去除了mixins，但其实vue3利用组合式api封装可复用逻辑和mixins是差不多类似的，只是在引入冲突时，不会像mixins那样产生默认覆盖这样的行为，而是会直接冲突报错。

mixins也是有坏处，毕竟高度封装等于不灵活，如果你想保证完全不出错使用，那就必须不能再对data的变量名重命名等等。以及在mixins和引入的发生冲突时，并不会报错，而是直接产生默认覆盖的行为。

现在在回过头看一下如果要写一个表格弹窗vue组件，需要多少行交互代码。这里不讨论html css，毕竟它们没办法抽出去复用的，以下设计交互部分的js methods里的代码，并且以单选框为例：

```js
methods: {
    // 确认勾选
    submitSelect() {
      this.setSelection('backup');
      const rows = this.filterSelectedRows();
      // this.$emit('','') 触发父组件更新输入框回显数据
    },

    // 获取表格数据
    loadData() {
      // 网络请求处理
    }
}
```

是的，就这么简洁了，只需要在vue里处理下emit事件，和获取表格数据事件就可以了，其它事件tableModalMixins.js都帮你做了

最后的最后，以我所做其中一个业务场景代码量简单的对比一下，不使用mixins之前vue文件里的js代码大概需要有200行左右，使用了mixins之后的子组件代码行数70行。代码减少量为65%。